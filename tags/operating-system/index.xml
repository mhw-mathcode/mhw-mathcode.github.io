<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Operating System on mhw</title>
        <link>https://mhw-mathcode.github.io/tags/operating-system/</link>
        <description>Recent content in Operating System on mhw</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>mhw-mathcode</copyright>
        <lastBuildDate>Tue, 12 Aug 2025 11:11:16 +0000</lastBuildDate><atom:link href="https://mhw-mathcode.github.io/tags/operating-system/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>学习笔记-操作系统</title>
        <link>https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Tue, 17 Jun 2025 18:27:49 +0800</pubDate>
        
        <guid>https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;p&gt;开个坑，主要是记录后续复习操作系统的一些笔记与完成 6.S081 课程的 lab 。&lt;/p&gt;
&lt;h2 id=&#34;1-概述&#34;&gt;1. 概述
&lt;/h2&gt;&lt;p&gt;操作系统的定义：操作系统是一组&lt;strong&gt;控制和管理&lt;/strong&gt;计算机软硬件资源，合理地&lt;strong&gt;组织&lt;/strong&gt;多道程序的运行，方便用户使用的程序的集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统是系统资源的管理者（处理机管理，存储器管理，文件管理，设备管理）；&lt;/li&gt;
&lt;li&gt;操作系统要向上提供方便易用的服务（GUI 接口，联机命令接口 = 交互式命令接口， 脱机命令接口 = 批处理命令接口，程序接口）；&lt;/li&gt;
&lt;li&gt;操作系统是最接近硬件的一层软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简述操作系统的基本特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发：指两个或多个事件在同一时间间隔内发生。宏观上同时发生，微观上交替发生。（并发 vs 并行）&lt;/li&gt;
&lt;li&gt;共享：系统中的资源可被多个并发执行的进程共同使用。并发性与共享性互为存在条件。&lt;/li&gt;
&lt;li&gt;虚拟：将物理实体映射成若干个逻辑设备。没有并发性，实现虚拟性就没有意义。（虚拟处理器技术：时分复用技术；虚拟存储器技术：空分复用技术）&lt;/li&gt;
&lt;li&gt;异步：多道程序下，由于资源有限，进程的执行是走走停停，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统的运行机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内核程序 vs 应用程序
CPU 执行的程序分为两种：操作系统内核程序、用户程序；
内核是操作系统最基础、核心的那部分；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特权指令 vs 非特权指令
内核程序，在计算机中的地位充当管理程序 ，所以可以执行特权指令；
用户程序，在计算机中的地位充当被管理程序 ，出于安全考虑只能执行非特权指令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核态 vs 用户态
【问题】CPU 可以区分特权指令和非特权指令 ，但是 CPU 无法识别正在执行的指令是应用程序的指令，还是内核程序的指令。
答：为了让 CPU 能够区分应用程序和内核程序 ，CPU会被划分为两种状态：内核态和用户态。&lt;/p&gt;
&lt;p&gt;内核态 - 内核程序 - 可以执行特权指令；
用户态 - 应用程序 - 只能执行非特权指令；&lt;/p&gt;
&lt;p&gt;CPU使用程序状态字寄存器（PSW） 实现对CPU状态的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何变态 ？
内核态转向用户态：执行一条特权指令，修改 PSW 的标志位为用户态；
用户态转向内核态：由&lt;strong&gt;中断&lt;/strong&gt;引发，硬件自动完成变态过程；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断与异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中断的作用：让操作系统内核强行夺回 CPU 控制权；使 CPU 从用户态变为内核态。（没有中断就无法实现并发）&lt;/li&gt;
&lt;li&gt;分类：
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.png&#34;
	width=&#34;1081&#34;
	height=&#34;578&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1_hu_ead3e0e924f55276.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1_hu_b4fea16bbcb9f663.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;中断与异常&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;187&#34;
		data-flex-basis=&#34;448px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;中断机制的基本原理：不同的中断信号，需要查询“中断信号表”来找到不同的中断处理程序来处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统调用：是操作系统提供给用户程序使用的接口，可以理解为一种特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。凡是与共享资源有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程：
&lt;ul&gt;
&lt;li&gt;一个应用程序运行在用户态，那么它的指令会CPU被一条条执行；&lt;/li&gt;
&lt;li&gt;当他想发出系统调用的时候，他需要&lt;strong&gt;传参指令&lt;/strong&gt;给CPU的寄存器传入某个参数，这个参数指明要进行哪种系统调用；传参指令可能多条，主要看需要的系统调用要求几个参数；&lt;/li&gt;
&lt;li&gt;当参数都传入寄存器之后，用户程序就会执行&lt;strong&gt;陷入指令&lt;/strong&gt;，这个陷入指令得到执行会引发一个内中断；&lt;/li&gt;
&lt;li&gt;CPU 检测到内部中断，发现这个内中断是由 &lt;strong&gt;trap 指令&lt;/strong&gt;引起的，就会暂停处理应用程序，转入相应的中断处理程序；&lt;/li&gt;
&lt;li&gt;CPU 转为内核态，&lt;strong&gt;处理系统调用入口程序&lt;/strong&gt;，根据参数判断需要哪种系统调用；对应系统调用的处理程序根据传入的其它参数，看看用户程序需要哪些具体服务；&lt;/li&gt;
&lt;li&gt;系统调用处理完，CPU切换为用户态，继续之前的用户程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统的体系结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统的内核
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.png&#34;
	width=&#34;1063&#34;
	height=&#34;534&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2_hu_46d683e60773cba9.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2_hu_867744d52652fd16.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;操作系统的内核&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;477px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;大内核与微内核
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.png&#34;
	width=&#34;822&#34;
	height=&#34;332&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3_hu_9db5b6c9b3d2f826.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3_hu_9a944c78eade466.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;大内核与微内核&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;247&#34;
		data-flex-basis=&#34;594px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;分层结构：每一层只能调用更低、相邻的那一层提供的功能接口；&lt;/li&gt;
&lt;li&gt;模块化：将操作系统分成多个模块，各模块之间协调工作；&lt;/li&gt;
&lt;li&gt;外核：用户直接使用硬件资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开机过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统要启动运行，操作系统的数据就需要被放进主存里面；计算机的主存，由 RAM 和 ROM 组成；ROM 存储芯片里存储 BIOS（基本输入输出系统），BIOS 里包含 ROM 引导程序。&lt;/li&gt;
&lt;li&gt;CPU 从一个特定主存地址开始，取指令，执行 ROM 中的引导程序（先进行硬件自检，再开机）；&lt;/li&gt;
&lt;li&gt;ROM 引导程序指示 CPU 将磁盘的第一块&amp;ndash;主引导记录读入内存，执行磁盘引导程序，扫描分区表；&lt;/li&gt;
&lt;li&gt;磁盘引导程序会根据分区表去找到C盘的位置，之后 CPU 读入 C 盘的引导记录 PBR。PBR 本身也是一种程序，CPU 就执行 PBR 里的程序，PBR 程序的主要作用就是找到启动管理器。启动管理器是在根目录里的一个程序，找到启动管理器，CPU 运行它，就开始了操作系统初始化的一系列操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-进程与线程&#34;&gt;2. 进程与线程
&lt;/h2&gt;&lt;h3 id=&#34;21-进程与线程&#34;&gt;2.1 进程与线程
&lt;/h3&gt;&lt;p&gt;进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位；&lt;/p&gt;
&lt;p&gt;​进程实体包括：PCB + 程序段 + 数据段 三部分；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PCB：进程描述信息（PID，UID）、进程控制和管理信息、资源分配信息；&lt;/li&gt;
&lt;li&gt;程序段：程序的代码；&lt;/li&gt;
&lt;li&gt;数据段：运行过程中出生的各种数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；&lt;/li&gt;
&lt;li&gt;并发性：内存中有多个进程实体，各进程可并发执行；&lt;/li&gt;
&lt;li&gt;独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位；&lt;/li&gt;
&lt;li&gt;异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制&amp;quot;来解决异步问题；&lt;/li&gt;
&lt;li&gt;结构性：每个进程都会配置一个PCB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的状态与转换：
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.png&#34;
	width=&#34;1340&#34;
	height=&#34;751&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4_hu_6c47587e6f604052.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4_hu_d0d533a934efe671.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;进程的状态与转换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;进程的组织方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链接方式：将同一状态的 PCB 链接成一个链表；&lt;/li&gt;
&lt;li&gt;索引方式：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的控制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程的创建&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;申请空白 PCB；&lt;/li&gt;
&lt;li&gt;为新进程分配所需资源；&lt;/li&gt;
&lt;li&gt;初始化 PCB；&lt;/li&gt;
&lt;li&gt;将 PCB 插入就绪队列；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从 PCB 集中中找到终止进程的 PCB；&lt;/li&gt;
&lt;li&gt;若进程正在运行，立刻剥夺 CPU， 将 CPU 分配给其它进程；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进程的阻塞&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;找到要阻塞的进程对应的 PCB；&lt;/li&gt;
&lt;li&gt;保护进程运行现场，将 PCB 状态信息设置为 阻塞态，暂时停止进程执行；&lt;/li&gt;
&lt;li&gt;将 PCB 插入相应事件的等待队列；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;进程的唤醒&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在事件等待队列中找到PCB；&lt;/li&gt;
&lt;li&gt;将 PCB 从等待队列移除，设置进程为就绪态；&lt;/li&gt;
&lt;li&gt;将 PCB 插入就绪队列，等待被调度；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;进程状态的切换&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将运行环境信息存入 PCB；&lt;/li&gt;
&lt;li&gt;PCB 移入相应队列；&lt;/li&gt;
&lt;li&gt;选择另一个进程执行，并更新其 PCB；&lt;/li&gt;
&lt;li&gt;根据 PCB 回复新进程所需的运行环境；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享存储：相互通信的进程互斥地共享某些数据结构或存储区，进程之间能够通过这些空间进行通信；&lt;/li&gt;
&lt;li&gt;消息传递：进程之间的数据交换以格式化的信息为单位，将通信的数据封装在信息中，并利用操作系统提供的一组通信命令（原语），在进程间进行信息传递，完成进程间的数据交换；
&lt;ul&gt;
&lt;li&gt;直接通信方式：送货上门&lt;/li&gt;
&lt;li&gt;间接通信方式：快递到驿站&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管道通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程：减少程序在并发执行时所付出的时间开销，提高 OS 的并发性能；引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。线程的实现方式包括用户级线程与内核级线程。TCB 线程控制块；TID 线程标识符。&lt;/p&gt;
&lt;h3 id=&#34;22-处理机调度&#34;&gt;2.2 处理机调度
&lt;/h3&gt;&lt;p&gt;处理机调度：进程数 &amp;gt; 处理机个数，需要对处理机进行分配。&lt;/p&gt;
&lt;p&gt;三层调度：
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.png&#34;
	width=&#34;1271&#34;
	height=&#34;579&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5_hu_b737851000d516bc.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5_hu_827e6aa394d3703f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三层调度&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;526px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;调度算法的评价指标：
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.png&#34;
	width=&#34;1158&#34;
	height=&#34;644&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6_hu_da8206864783234d.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6_hu_5eef6beb66f515b4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;调度算法的评价指标&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;进程调度：就是按照某种算法从就绪队列中选择一个进程为其分配处理机。进程在操作系统内核程序临界区中不能进行程序调度与切换的情况（普通临界区可以）。&lt;/p&gt;
&lt;p&gt;调度算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先来先服务（FCFS）：按照进程到达的先后顺序；&lt;/li&gt;
&lt;li&gt;短作业优先（SJF）：服务时间最短的进程优先；抢占式版本：最短剩余时间优先算法 SRTN；&lt;/li&gt;
&lt;li&gt;高响应优先（HRRN）：响应比 = (等待时间 + 要求服务时间) / 要求服务时间；&lt;/li&gt;
&lt;li&gt;时间片轮转调度算法（RR）：根据进程到达就绪队列的顺序，轮流调度；&lt;/li&gt;
&lt;li&gt;优先级调度算法：调度时选择优先级最高的；&lt;/li&gt;
&lt;li&gt;多级反馈队列调度算法：设置多级就绪队列；各队列按照 FCFS + 时间片，时间片结束进入下一级队列队尾；只有第 k 级队列为空时，才会为 k+1 级分配时间片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同步与互斥：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：并发进程为完成同一任务所进行的工作顺序协调；&lt;/li&gt;
&lt;li&gt;互斥：并发进程为竞争临界资源所进行的资源分时占用。&lt;/li&gt;
&lt;li&gt;进程互斥遵循的原则：
&lt;ul&gt;
&lt;li&gt;空闲让进：临界区空闲时，应允许一个进程访问&lt;/li&gt;
&lt;li&gt;忙则等待：临界区正在被访问时，其他试图访问的进程需要等待&lt;/li&gt;
&lt;li&gt;有限等待：要在有限时间内进入临界区，保证不会饥饿&lt;/li&gt;
&lt;li&gt;让权等待：进不了临界区的进程，要释放处理机，防止忙等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;互斥锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁填充采用硬件来实现获得锁、释放锁的原子性；每个互斥锁有一个布尔变量 available ，表示锁释放可用；&lt;/li&gt;
&lt;li&gt;特点：忙等，违反了让权等待；等待代价较低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量机制的概念：把系统中的资源抽象化为变量，信号量记录着资源数；提供一对原语 wait(S) 和 signal(S) 来保证对信号量 S 操作的原子性（wait、signal 操作常被成为 P、V 原语）。&lt;/li&gt;
&lt;li&gt;类别：
&lt;ul&gt;
&lt;li&gt;整型信号量：用一个整数型变量作为信号量，用来表示系统中某种资源的数量。但是不满足让权等待原则。&lt;/li&gt;
&lt;li&gt;记录型信号量
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.png&#34;
	width=&#34;1335&#34;
	height=&#34;745&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7_hu_ddf1ed0dac0b443d.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7_hu_f7d00874cf372e51.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;记录型信号量&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;430px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用：
&lt;ul&gt;
&lt;li&gt;实现进程互斥；&lt;/li&gt;
&lt;li&gt;实现进程同步；&lt;/li&gt;
&lt;li&gt;实现前驱关系。
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.png&#34;
	width=&#34;1337&#34;
	height=&#34;724&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8_hu_b4c55380422bb06e.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8_hu_93ab1c3f24738b1f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;信号量的使用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经典同步问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者-消费者问题
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.png&#34;
	width=&#34;1081&#34;
	height=&#34;598&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10_hu_6b334b2ae73a2c56.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10_hu_d239d178647bde51.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;生产者-消费者问题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;180&#34;
		data-flex-basis=&#34;433px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;读者-写者问题
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.png&#34;
	width=&#34;1226&#34;
	height=&#34;655&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9_hu_b0ff338c83a5bc0c.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9_hu_8129f8d2a084e12.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;读者-写者问题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;187&#34;
		data-flex-basis=&#34;449px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;哲学家进餐问题
&lt;img src=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.png&#34;
	width=&#34;1225&#34;
	height=&#34;683&#34;
	srcset=&#34;https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11_hu_301471c3961d7b8f.png 480w, https://mhw-mathcode.github.io/p/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11_hu_5dbfd90316c092e2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;哲学家进餐问题&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;430px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;死锁：各进程互相等待对方的资源，导致各进程都阻塞（资源永远不会释放）。
特点：至少两个或两个以上的进程同时死锁；处于阻塞态。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;区分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;饥饿：长期得不到想要的资源（资源会释放，但不会被分配）
特点：一个进程也可能出现饥饿现象；可能阻塞态（等 IO），也可能就绪态 （等 CPU）。&lt;/li&gt;
&lt;li&gt;死循环：死锁和饥饿是由资源的不合理分配导致，死循环是由代码逻辑错误导致。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;形成的必要条件：
&lt;ul&gt;
&lt;li&gt;互斥条件：只有对互斥资源的争抢才会导致死锁。&lt;/li&gt;
&lt;li&gt;不可剥夺条件：进程保持的资源只能主动释放，不可强行剥夺。&lt;/li&gt;
&lt;li&gt;请求和保持条件：保证着某些资源不放的同时，请求别的资源。&lt;/li&gt;
&lt;li&gt;循环等待条件：存在一种进程资源的循环等待链；循环等待未必死锁，死锁必定循环等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁预防：破坏死锁的四个必要条件（完全没有死锁的可能）。&lt;/li&gt;
&lt;li&gt;死锁避免：避免系统进入不安全状态（有可能死锁，避免陷入死锁）。
银行家算法 ：在资源分配之前，先判断此次分配是否会导致系统进入 不安全状态 ，再决定是否分配资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-内存管理&#34;&gt;3. 内存管理
&lt;/h2&gt;&lt;p&gt;内存的一大作用是缓和 CPU 与硬盘之间的速度矛盾。&lt;/p&gt;
&lt;p&gt;内存管理任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存空间的分配与回收&lt;/li&gt;
&lt;li&gt;内存空间的扩充：从逻辑上对内存空间进行扩充&lt;/li&gt;
&lt;li&gt;地址转换：逻辑地址与物理地址的转换&lt;/li&gt;
&lt;li&gt;存储保护：保证各进程在各自存储空间内运行，互不干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程运行的基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建进程首先要将程序和数据装入内存；&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;用户源程序&lt;/strong&gt;变为&lt;strong&gt;可在内存中执行的程序&lt;/strong&gt;，通常需要以下几个步骤：
&lt;ul&gt;
&lt;li&gt;编译：由&lt;strong&gt;编译程序&lt;/strong&gt;将&lt;strong&gt;用户源代码&lt;/strong&gt;编译成&lt;strong&gt;若干个模块&lt;/strong&gt;（机器指令）；&lt;/li&gt;
&lt;li&gt;链接：由&lt;strong&gt;链接程序&lt;/strong&gt;将编译后形成的一组目标模块及它们所需的&lt;strong&gt;库函数&lt;/strong&gt;链接在一起，形成一个完整的&lt;strong&gt;装入模块&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;装入：由&lt;strong&gt;装入程序&lt;/strong&gt;将&lt;strong&gt;装入模块&lt;/strong&gt;装入内存运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
